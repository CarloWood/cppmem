(*Generated by Lem from ../axiomatic/ntc/cmm.lem.*)
open Nat_num

type 'a set = 'a Pset.set

(*========================================================================*)
(*                                                                        *)
(*             cppmem model exploration tool                              *)
(*                                                                        *)
(*                    Mark Batty                                          *)
(*                    Scott Owens                                         *)
(*                    Jean Pichon                                         *)
(*                    Susmit Sarkar                                       *)
(*                    Peter Sewell                                        *)
(*                                                                        *)
(*  This file is copyright 2011, 2012 by the above authors.               *)
(*                                                                        *)
(*  Redistribution and use in source and binary forms, with or without    *)
(*  modification, are permitted provided that the following conditions    *)
(*  are met:                                                              *)
(*  1. Redistributions of source code must retain the above copyright     *)
(*  notice, this list of conditions and the following disclaimer.         *)
(*  2. Redistributions in binary form must reproduce the above copyright  *)
(*  notice, this list of conditions and the following disclaimer in the   *)
(*  documentation and/or other materials provided with the distribution.  *)
(*  3. The names of the authors may not be used to endorse or promote     *)
(*  products derived from this software without specific prior written    *)
(*  permission.                                                           *)
(*                                                                        *)
(*  THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS    *)
(*  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED     *)
(*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE    *)
(*  ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY       *)
(*  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL    *)
(*  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE     *)
(*  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS         *)
(*  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHE   *)
(*  IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR       *)
(*  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN   *)
(*  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                         *)
(*========================================================================*)

(* emacs fontification -*-caml-*- *)

(*

--- Introduction ---

This file contains a mathematical version of the relaxed memory model
of C11 and C++11, written in the specification language of Lem. Lem
can compile it to Ocaml, HOL, Isabelle or Latex. The basic model is
faithful to the intent of the 2011 standard and included here in
full. In addition, there are several simplified models that either remove
redundant concepts or provide simplifications for programs that
restrict the input language of programs.

There are lots of definitions that make up the models. To help you
navigate them, the following table of contents (with unique key
phrases) can be used to search the document. Where appropriate, there
are comments describing or explaining the definitions. These are
especially important for the top-level definitions of the simplified models.

--- Contents ---


1 - Relational definitions

2 - Type definitions and projections

  - 2.1 - Action and location types

  - 2.2 - Execution records

  - 2.3 - Projection functions 

  - 2.4 - Location kinds

3 - The preferred model

  - 3.1  - Well formed action

  - 3.2  - Well formed threads

  - 3.3  - Consistent locks

  - 3.4  - Well formed reads from mapping

  - 3.5  - Happens before

  - 3.6  - Consistent SC and modification orders

  - 3.7  - Visible side effects and VSSEs

  - 3.8 - Consistent reads from mapping

  - 3.9  - Undefined behaviour

  - 3.10 - Consistent execution

  - 3.11 - Preferred model top level judgement

4 - Standard C/C++ model

5 - Model with separate lock order

6 - Model with per-location lock orders

7 - Model with per-location lock orders and sc order

8 - Model with single step mutex synchronisation

9 - Model simplified for programs without consumes

10 - Model simplified for programs without consumes or relaxed

11 - Model simplified for programs without consumes, relaxed, acquires or releases

12 - Model simplified to a single thread, no atomics

13 - Model simplified, single thread, no atomics 2

14 - Model simplified, multi-thread, no atomics, yes locks

*)





(*************************************************** *)
(* 1 - Relational definitions *)
(*************************************************** *)


let irrefl s ord = Pset.for_all (fun x -> not ( Pset.mem (x,x)  ord)) s

let trans s ord = Pset.for_all (fun x -> Pset.for_all (fun y -> Pset.for_all (fun z -> (not  (( Pset.mem (x,y)  ord) && ( Pset.mem (y,z)  ord)) ||  ( Pset.mem (x,z)  ord))) s) s) s

let cross s t = let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun s x2 -> Pset.fold (fun t x2 -> if true then Pset.add (s,t) x2 else x2) t x2) s x2

(*val tc : forall 'a. set ('a * 'a) -> set ('a * 'a)*)

(* indreln {isabelle} *)
(*   forall r x y. r (x, y) ==> tc' r (x, y) and  *)
(*   forall r x y. (exist z. tc' r (x,z) && tc' r (z,y)) ==> tc' r (x,y)  *)

(* let {isabelle} tc r = *)
(*  let r' = fun (x,y) -> ((x,y) IN r) in   *)
(*  { (x,y) | forall ((x,y) IN r) | tc' r' (x,y) } *)

let rec tc r =
  let one_step = let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun(x,y) x2 -> Pset.fold (fun(y',z) x2 -> if y = y' then Pset.add (x,z) x2 else x2) r x2) r x2 in
  if Pset.subset  one_step  r then r else
  tc ( Pset.union one_step  r)

let set_restrict rel s = Pset.inter  (rel)  (cross s s)

let strict_partial_order s ord = irrefl s ord && trans s ord

let relation_over s rel = Pset.for_all (fun (a,b) -> Pset.mem  a  s && Pset.mem  b  s) rel 

let inj_on f a =
    (Pset.for_all (fun x -> (Pset.for_all (fun y -> (not  (f x = f y) ||  (x = y))) a)) a)

let total s ord =
     (Pset.for_all (fun x -> Pset.for_all (fun y -> Pset.mem  (x,y)  ord || (Pset.mem  (y,x)  ord || (x = y))) s) s)

let strict_total_order_over s ord =
    relation_over s ord &&
    (strict_partial_order s ord &&
    total s ord)

let adjacent_less_than ord s x y = Pset.mem 
    (x,y)  ord && not (Pset.exists (fun z -> Pset.mem  (x,z)  ord && Pset.mem  (z,y)  ord) s)

let adjacent_less_than_such_that pred ord s x y =
    pred x && (Pset.mem  (x,y)  ord && not (Pset.exists (fun z -> pred z && (Pset.mem  (x,z)  ord && Pset.mem  (z,y)  ord)) s))

(*************************************************** *)
(* 2 - Type definitions and projections *)
(*************************************************** *)


(*************************************************** *)
(* - 2.1 - Action and location types *)
(*************************************************** *)


(**** Cppmem base types ****)

type flexsym = string

type cst =
  | Concrete of num
  | Symbolic of string

type cvalue =
  | Rigid of cst
  | Flexible of flexsym

type aid = string
type tid = cvalue
type location = cvalue
type program = num



type memory_order =
  | NA
  | Seq_cst
  | Relaxed
  | Release
  | Acquire
  | Consume
  | Acq_rel

type lock_outcome =
    Locked
  | Blocked

type action =
  | Lock of aid * tid * location * lock_outcome
  | Unlock of aid * tid * location
  | Load of aid * tid * memory_order * location * cvalue
  | Store of aid * tid * memory_order * location * cvalue
  | RMW of aid * tid * memory_order * location * cvalue * cvalue
  | Fence of aid * tid * memory_order
  | Blocked_rmw of aid * tid * location



(*********************************************** *)
(*  - 2.2 - Execution records *)
(*********************************************** *)

let dummy22 = true

type location_kind =
    Mutex
  | Non_Atomic
  | Atomic

type pre_execution =
  {  actions : action set;
      threads : tid set;
      lk      : location -> location_kind;
      sb      : (action * action) set ;
      asw     : (action * action) set ;
      dd      : (action * action) set ;
(*    cd      : set (action * action) ;*)
  }

type order_kind =
     Global_order
   | Per_location_order

type relation_usage_flags =
  {  rf_flag  : bool;
      mo_flag  : bool;
      sc_flag  : bool;
      lo_flag  : order_kind option;
      ao_flag  : bool;
      tot_flag : bool;  }

type execution_witness =
  {  rf      : (action * action) set;
      mo      : (action * action) set;
      sc      : (action * action) set;
      lo      : (action * action) set;
      ao      : (action * action) set;
      tot     : (action * action) set;
 }

type relation_list = (string * (action * action) set) list

type complete_execution = (pre_execution * execution_witness * relation_list)

type program_behaviours =
    Defined of complete_execution set
  | Undefined

type named_predicate_tree =
    Leaf of (complete_execution -> bool)
  | Node of (string * named_predicate_tree) list

(*
let rec apply_tree pred_tree X =
    let element_apply_and (name,branch) P = apply_tree branch X && P in
      match pred_tree with
        Leaf p -> p X
      | Node l -> List.fold_right element_apply_and l true end
*)

let rec apply_tree pred_tree x =
      (match pred_tree with
        Leaf( p) -> p x
      | Node( l) -> List.fold_right 
                    (fun (name,branch) p -> apply_tree branch x && p)
                    l true )

type fault_setgen =
    One of (string * (complete_execution -> action set))
  | Two of (string * (complete_execution -> (action * action) set))



let each_empty faults_list x =
    let faults_empty f =
      (match f with
        One( (name,setgen)) -> (setgen x = Pset.from_list Pervasives.compare [])
      | Two( (name,setgen)) -> (setgen x = Pset.from_list Pervasives.compare []) ) in
    List.for_all faults_empty faults_list


type opsem_t = program -> pre_execution -> bool


type protocol_t = complete_execution -> bool

let true_protocol _ = true

type memory_model =
  {  consistent : named_predicate_tree;
      relation_calculation : pre_execution -> execution_witness ->
  relation_list;
      undefined : fault_setgen list;
      relation_flags : relation_usage_flags;
  }


(*val behaviour : memory_model -> protocol_t -> opsem_t -> program -> program_behaviours*)


(*************************************************** *)
(*   - 2.3 - Projection functions *)
(*************************************************** *)

let dummy23 = true

let aid_of a =
    (match a with
    | Lock( aid, _, _, _)            -> aid
    | Unlock( aid, _, _)            -> aid
    | Load( aid, _, _, _, _)          -> aid
    | Store( aid, _, _, _, _)         -> aid
    | RMW( aid, _, _, _, _, _)         -> aid
    | Fence( aid, _, _)             -> aid
    | Blocked_rmw( aid, _, _)       -> aid
    )


let tid_of a =
    (match a with
      Lock( _, tid, _, _)           -> tid
    | Unlock( _, tid, _)           -> tid
    | Load( _, tid, _, _, _)         -> tid
    | Store( _, tid, _, _, _)        -> tid
    | RMW( _, tid, _, _, _, _)        -> tid
    | Fence( _, tid, _)            -> tid
    | Blocked_rmw( _, tid, _)      -> tid
    )



let loc_of a =
    (match a with
      Lock( _, _, l, _)           -> Some( l)
    | Unlock( _, _, l)           -> Some( l)
    | Load( _, _, _, l, _)         -> Some( l)
    | Store( _, _, _, l, _)        -> Some( l)
    | RMW( _, _, _, l, _, _)        -> Some( l)
    | Fence( _, _, _)            -> None
    | Blocked_rmw( _, _, l)      -> Some( l)
    )

let value_read_by a =
    (match a with
      Load( _, _, _, _, v)         -> Some( v)
    | RMW( _, _, _, _, v, _)        -> Some( v)
    | _                      -> None
    )


let value_written_by a =
    (match a with
      Store( _, _, _, _, v)        -> Some( v)
    | RMW( _, _, _, _, _, v)        -> Some( v)
    | _                      -> None
    )

let is_lock a =
    (match a with
      Lock( _, _, _, _) -> true
    | _            -> false
    )

let is_successful_lock a =
    (match a with
      Lock( _, _, _, Locked) -> true
    | _                  -> false
    )

let is_blocked_lock a =
    (match a with
      Lock( _, _, _, Blocked) -> true
    | _                  -> false
    )

let is_unlock a =
    (match a with
      Unlock( _, _, _) -> true
    | _            -> false
    )

let is_atomic_load a =
    (match a with
      Load( _, _, mo, _, _) -> mo <> NA
    | _               -> false
    )

let is_atomic_store a =
    (match a with
      Store( _, _, mo, _, _) -> mo <> NA
    | _                -> false
    )

let is_RMW a =
    (match a with
      RMW( _, _, _, _, _, _) -> true
    | _               -> false
    )

let is_blocked_rmw a =
    (match a with
      Blocked_rmw( _, _, _) -> true
    | _                 -> false
    )

let is_NA_load a =
    (match a with
      Load( _, _, mo, _, _) -> mo = NA
    | _               -> false
    )

let is_NA_store a =
    (match a with
      Store( _, _, mo, _, _) -> mo = NA
    | _                -> false
    )

let is_load a =
    (match a with
      Load( _, _, _, _, _) -> true
    | _              -> false
    )

let is_store a =
    (match a with
      Store( _, _, _, _, _) -> true
    | _               -> false
    )

let is_fence a =
    (match a with
      Fence( _, _, _) -> true
    | _           -> false
    )

let is_atomic_action a =
    (match a with
      Load( _, _, mo, _, _)  -> mo <> NA
    | Store( _, _, mo, _, _) -> mo <> NA
    | RMW( _, _, _, _, _, _)  -> true
    | _                -> false
    )

let is_read a =
    (match a with
      Load( _, _, _, _, _)  -> true
    | RMW( _, _, _, _, _, _) -> true
    | _               -> false
    )

let is_write a =
    (match a with
      Store( _, _, _, _, _) -> true
    | RMW( _, _, _, _, _, _) -> true
    | _               -> false
    )


(* It is important to note that seq_cst atomics are both acquires and releases *)

let dummy23' = true

let is_acquire a = 
    (match a with
      Load( _, _, mo, _, _)  -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Acquire;Seq_cst])
    | RMW( _, _, mo, _, _, _) -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Acquire;Acq_rel;Seq_cst])
    | Fence( _, _, mo)     -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Acquire;Seq_cst])
    | _                -> false
    )

let is_release a = 
    (match a with
      Store( _, _, mo, _, _)  -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Release;Seq_cst])
    | RMW( _, _, mo, _, _, _)  -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Release;Acq_rel;Seq_cst])
    | Fence( _, _, mo)      -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Release;Seq_cst])
    | _                 -> false
    )

let is_consume a = 
    (match a with
      Load( _, _, mo, _, _)  -> mo = Consume
    | _                -> false
    )


let is_seq_cst a =
    (match a with
      Load( _, _, mo, _, _)  -> mo = Seq_cst
    | RMW( _, _, mo, _, _, _) -> mo = Seq_cst
    | Fence( _, _, mo)     -> mo = Seq_cst
    | _                -> false
    )


let threadwise s rel = Pset.for_all (fun (a,b) -> tid_of a = tid_of b) rel

let locationwise s rel = Pset.for_all (fun (a,b) -> loc_of a = loc_of b) rel

let per_location_total s rel =
    Pset.for_all (fun a -> Pset.for_all (fun b -> (not  (loc_of a = loc_of b) || (Pset.mem  
      (a,b)  rel || (Pset.mem  (b,a)  rel || (a = b))))) s) s


(**************************************** *)
(*   - 2.4 - Location kinds *)
(**************************************** *)

let dummy24 = true

(* let actions_respect_location_kinds actions lk = *)
(*   forall (a IN actions). match loc_of a with *)
(*       Some l -> *)
(*           match lk l with *)
(*             Mutex      -> is_lock a     || is_unlock a *)
(*           | Non_Atomic -> is_NA_load a  || is_NA_store a *)
(*           | Atomic     -> is_NA_store a || is_atomic_action a || is_blocked_rmw a end *)
(*     | None   -> true *)
(*     end *)

let dummy241 = true


let actions_respect_location_kinds actions lk =
 Pset.for_all (fun a -> (match a with
    | Lock( _, _, l, _)            -> lk l = Mutex
    | Unlock( _, _, l)            -> lk l = Mutex
    | Load( _, _, mo, l, _)         ->
        (mo = NA && (lk l = Non_Atomic)) || (lk l = Atomic)
    | Store( _, _, mo, l, _)        ->
        (mo = NA && (lk l = Non_Atomic)) || (lk l = Atomic)
    | RMW( _, _, _, l, _, _)         -> lk l = Atomic
    | Fence( _, _, _)             -> true
    | Blocked_rmw( _, _, l)       -> lk l = Atomic
    )) actions


let is_at_mutex_location lk a =
    (match loc_of a with
      Some( l) -> (lk l = Mutex)
    | None   -> false
    )

let is_at_non_atomic_location lk a =
    (match loc_of a with
      Some( l) -> (lk l = Non_Atomic)
    | None   -> false
    )

let is_at_atomic_location lk a =
    (match loc_of a with
      Some( l) -> (lk l = Atomic)
    | None   -> false
    )


(**************************************** <a name="preferred">*)
(* 3 - The preferred memory_model *)
(**************************************** *)


(* This simplification should be equivalent to the Standard's memory_model
   (section 4) (this was verified for earlier versions using the HOL
   theorem prover). It removes the complicated notion of VSSE's, whose
   force is covered by the coherence requirements.  For those looking
   to work with C or C++ concurrency, this is the preferred
   memory_model. Predicates from this memory_model will be used in those that
   follow. *)


(**************************************** *)
(*   - 3.1 - Well formed action *)
(**************************************** *)

let dummy31 = true

let locations_of actions =
let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun x1 x2 -> (match x1 with Some( l) -> if true then Pset.add l x2 else x2 | _ -> x2)) (let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if true then Pset.add (loc_of a) x2 else x2) actions x2) x2


let well_formed_action a =
  (match a with
    | Load(  _, _, mo, _, _) -> Pset.mem  mo  (Pset.from_list Pervasives.compare [NA;Relaxed;Acquire;Seq_cst;Consume])
    | Store( _, _, mo, _, _) -> Pset.mem  mo  (Pset.from_list Pervasives.compare [NA;Relaxed;Release;Seq_cst])
    | RMW( _, _, mo, _, _, _) -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Relaxed;Release;Acquire;Acq_rel;Seq_cst])
    | Fence( _, _, mo)     -> Pset.mem  mo  (Pset.from_list Pervasives.compare [Release;Acquire;Seq_cst])
    | _                -> true
    )

(*********************************************** *)
(*  - 3.2 - Well formed threads *)
(*********************************************** *)

(*
    relation_over Xo.actions Xo.cd &&
    threadwise Xo.actions Xo.cd &&
    strict_partial_order Xo.actions Xo.cd &&
    Xo.cd subset Xo.sb &&
*)

let dummy32 = true

let blocking_observed actions sb =
    (Pset.for_all (fun a -> 
       (not  
       (is_blocked_rmw a || is_blocked_lock a) ||  
       not (Pset.exists (fun b -> Pset.mem  (a,b)  sb) actions))) actions)


(* This should really be moved to the undefined behaviour... not sure now.*)

let dummy32' = true

let well_formed_threads (xo,_,_) =
    (Pset.for_all (fun a -> well_formed_action a) xo.actions) && (* especially this *)
    (actions_respect_location_kinds xo.actions xo.lk &&
    (blocking_observed xo.actions xo.sb &&
    (inj_on aid_of xo.actions &&
    ((Pset.for_all (fun a -> Pset.mem  (tid_of a)  xo.threads) xo.actions) &&
    (relation_over xo.actions xo.sb &&
    (relation_over xo.actions xo.dd &&
    (relation_over xo.actions xo.asw &&
    (threadwise xo.actions xo.sb &&
    (threadwise xo.actions xo.dd &&
    (strict_partial_order xo.actions xo.sb &&
    (strict_partial_order xo.actions xo.dd && Pset.subset 
    xo.dd  xo.sb)))))))))))

(*********************************************** *)
(*   - 3.3 - Consistent locks *)
(*********************************************** *)

let dummy33 = true

let consistent_locks (xo,xw,("hb",hb)::_) =
    (Pset.for_all (fun (a,c) ->
      (not  
      (is_successful_lock a && (is_successful_lock c && (loc_of a = loc_of c))) ||  
      (Pset.exists (fun b -> (loc_of a = loc_of b) && (is_unlock b && (Pset.mem  (a,b)  xw.sc && Pset.mem  (b,c)  xw.sc))) xo.actions))) xw.sc)

(*********************************************** *)
(*  - 3.4 - Well formed reads from mapping *)
(*********************************************** *)


let dummy34 = true


let well_formed_rf (xo,xw,_) =
    Pset.for_all (fun (a,b) -> Pset.mem 
      a  xo.actions && (Pset.mem  b  xo.actions &&
      (loc_of a = loc_of b &&
      (is_write a && (is_read b &&
      (value_read_by b = value_written_by a &&
      Pset.for_all (fun a' -> (not (Pset.mem   (a',b)  xw.rf) ||  (a = a'))) xo.actions)))))) xw.rf


(*********************************************** *)
(*   - 3.5 - Happens before *)
(*********************************************** *)

let dummy35 = true

let rs_element head a =
    (tid_of a = tid_of head) || is_RMW a


let release_sequence actions lk mo a_rel b =
    is_release a_rel &&
    ( (b = a_rel) ||
      ( rs_element a_rel b && (Pset.mem  (a_rel,b)  mo &&
        (Pset.for_all (fun c -> (not  ( Pset.mem (a_rel,c)  mo && Pset.mem  (c,b)  mo) ||  rs_element a_rel c)) actions)) ) )

(* let release_sequence_set actions lk mo = *)
(*     { (a,b) | forall (a IN actions) (b IN actions) | *)
(*        release_sequence actions lk mo a b} *)


let release_sequence_set actions lk mo =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun rel x2 -> Pset.fold (fun b x2 -> if
    is_release rel &&
    ( (b = rel) ||
      ( Pset.mem  (rel,b)  mo && 
        (rs_element rel b &&
        Pset.for_all (fun c -> (not 
          ( Pset.mem (rel,c)  mo && Pset.mem  (c,b)  mo) ||  rs_element rel c)) actions) ) ) then Pset.add (rel,b) x2 else x2) actions x2) actions x2


let hypothetical_release_sequence_set actions lk mo =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
    is_at_atomic_location lk a &&
    (is_write a &&
    ( (b = a) ||
      ( Pset.mem  (a,b)  mo && 
        (rs_element a b &&
        Pset.for_all (fun c -> (not 
          ( Pset.mem (a,c)  mo && Pset.mem  (c,b)  mo) ||  rs_element a c)) actions) ) )) then Pset.add (a,b) x2 else x2) actions x2) actions x2

let hypothetical_release_sequence actions lk mo a b =
    is_at_atomic_location lk a &&
    (is_write a &&
    ( (b = a) ||
      ( rs_element a b && (Pset.mem  (a,b)  mo &&
        (Pset.for_all (fun c -> (not  ( Pset.mem (a,c)  mo && Pset.mem  (c,b)  mo) ||  rs_element a c)) actions)) ) ))


(* let hypothetical_release_sequence_set actions lk mo = *)
(*     { (a,b) | forall (a IN actions) (b IN actions) | *)
(*        hypothetical_release_sequence actions lk mo a b} *)


let synchronizes_with actions sb asw rf lo rs hrs a b = Pset.mem 
    (* thread sync *)
    (a,b)  asw ||
    ( (loc_of a = loc_of b) && (Pset.mem  a  actions && (Pset.mem  b  actions &&
      ( (* mutex sync *)
        (* this seems to be the multi loc lo version... *)
        (is_unlock a && (is_successful_lock b && Pset.mem  (a,b)  lo)) ||
        (* rel/acq sync *)
        (( is_release a && (is_acquire b && ((tid_of a <> tid_of b) &&
          (Pset.exists (fun c -> Pset.mem  (a,c)  rs && Pset.mem  (c,b)  rf) actions ))) ) ||
        (* fence sync *)
        (( (tid_of a <> tid_of b) &&
          (is_fence a && (is_release a && (is_fence b && (is_acquire b &&
          ( Pset.exists (fun x -> Pset.exists (fun y -> (loc_of x = loc_of y) &&
              (is_atomic_action x && (is_atomic_action y && (is_write x && (Pset.mem 
              (a,x)  sb && (Pset.mem  (y,b)  sb &&
              ( Pset.exists (fun z -> Pset.mem  (x,z)  hrs && Pset.mem  (z,y)  rf) actions))))))) actions) actions ))))) ) ||
        (( (tid_of a <> tid_of b) &&
          (is_fence a && (is_release a && (is_atomic_action b && (is_acquire b &&
          ( Pset.exists (fun x -> (loc_of x = loc_of b) &&
            (is_atomic_action x && (is_write x && (Pset.mem  (a,x)  sb &&
            ( Pset.exists (fun z -> Pset.mem  (x,z)  hrs && Pset.mem  (z,b)  rf) actions ))))) actions ))))) ) ||
        ( (tid_of a <> tid_of b) &&
          (is_atomic_action a && (is_release a &&
          (is_fence b && (is_acquire b &&
          ( Pset.exists (fun x -> (loc_of a = loc_of x) && (is_atomic_action x && (Pset.mem 
            (x,b)  sb &&
            ( Pset.exists (fun z -> Pset.mem  (a,z)  rs && Pset.mem  (z,x)  rf) actions )))) actions ))))) )))) ))) )


let synchronizes_with_set actions sb asw rf lo rs hrs =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       synchronizes_with actions sb asw rf lo rs hrs a b then Pset.add (a,b) x2 else x2) actions x2) actions x2

let carries_a_dependency_to_set actions sb dd rf = tc ( Pset.union  ( Pset.inter rf  sb)  dd )

let dependency_ordered_before actions rf rs cad a d = Pset.mem 
     a  actions && (Pset.mem  d  actions &&
     ( Pset.exists (fun b -> is_release a && (is_consume b &&
       ((Pset.exists (fun e -> Pset.mem  (a,e)  rs && Pset.mem  (e,b)  rf) actions) &&
       ( Pset.mem  (b,d)  cad || (b = d) )))) actions ))

let dependency_ordered_before_set actions rf rs cad =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       dependency_ordered_before actions rf rs cad a b then Pset.add (a,b) x2 else x2) actions x2) actions x2


let compose r1 r2 =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun(w,x) x2 -> Pset.fold (fun(y,z) x2 -> if (x = y) then Pset.add (w,z) x2 else x2) r2 x2) r1 x2 


let inter_thread_happens_before actions sb sw dob =
    let r = Pset.union (Pset.union   sw  dob)  (compose sw sb) in
      tc ( Pset.union r  (compose sb r))


let consistent_ithb
      (xo,xw,("hb",hb)::_::_::("ithb",ithb)::_) =
    irrefl xo.actions ithb

let happens_before actions sb ithb = Pset.union 
    sb  ithb

(*********************************************** *)
(*   - 3.6 - Consistent SC and modification orders *)
(*********************************************** *)

let dummy36 = true

let consistent_sc (xo,xw,("hb",hb)::_) =
    let all_sc_actions =
      let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if
        is_seq_cst a || (is_lock a || is_unlock a) then Pset.add a x2 else x2) xo.actions x2 in
    let sc_happens_before = set_restrict hb (all_sc_actions) in
    let sc_mod_order = set_restrict xw.mo all_sc_actions in
    strict_total_order_over all_sc_actions xw.sc && (Pset.subset 
    sc_happens_before  xw.sc && Pset.subset 
    sc_mod_order  xw.sc)




let consistent_mo (xo,xw,("hb",hb)::_) =
    trans xo.actions xw.mo &&
    (irrefl xo.actions xw.mo &&
    Pset.for_all (fun a -> Pset.for_all (fun b -> (not (Pset.mem  
      (a,b)  xw.mo) ||  (not ( Pset.mem (b,a)  hb) &&
      (( Pset.mem (a,b)  xw.mo || Pset.mem  (b,a)  xw.mo)
      = ( is_write a && (is_write b &&
          ((loc_of a = loc_of b) &&
          is_at_atomic_location xo.lk a)) ))))) xo.actions) xo.actions)


(* let consistent_mo_old (Xo,Xw,("hb",hb)::_) = *)
(*     (forall (a IN Xo.actions) (b IN Xo.actions). (a,b) IN Xw.mo --> ((loc_of a = loc_of b) && is_write a && is_write b)) && *)
(*     ( forall (l IN locations_of Xo.actions). *)
(*              match Xo.lk l with *)
(*           Atomic ->  *)
(*             ( let actions_at_l = {a | forall (a IN Xo.actions) | loc_of a = Some l} in *)
(*               let writes_at_l = {a | forall (a IN actions_at_l) | is_write a} in *)
(*                 strict_total_order_over writes_at_l (set_restrict Xw.mo actions_at_l) && *)
(*                 (* hb is a subset of mo at l *) *)
(*                 set_restrict hb writes_at_l subset Xw.mo ) *)
(*         | _      -> *)
(*             ( let actions_at_l = {a | forall (a IN Xo.actions) | loc_of a = Some l} in *)
(*                 Set.is_empty (set_restrict Xw.mo actions_at_l) ) end  *)


(*********************************************** *)
(*   - 3.7 - Visible side effects *)
(*********************************************** *)


(* let visible_side_effect actions hb a b = *)
(*     (a,b) IN hb && *)
(*     is_write a && is_read b && (loc_of a = loc_of b) && *)
(*     not ( exists (c IN actions). not (c = a) && not (c = b) && *)
(*           is_write c && (loc_of c = loc_of b) && *)
(*           (a,c) IN hb && (c,b) IN hb) *)

let dummy37 = true

let visible_side_effect_set actions hb =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun(a,b) x2 -> if
      is_write a && (is_read b && ((loc_of a = loc_of b) &&
      not ( Pset.exists (fun c -> not ( Pset.mem c  (Pset.from_list Pervasives.compare [a;b])) &&
          (is_write c && ((loc_of c = loc_of b) && (Pset.mem 
          (a,c)  hb && Pset.mem  (c,b)  hb)))) actions))) then Pset.add (a,b) x2 else x2) hb x2



(*********************************************** *)
(*   - 3.8 - Consistent reads from mapping *)
(*********************************************** *)

let dummy38 = true

let det_read (xo,xw,("hb",hb)::_) =
    Pset.for_all (fun r -> (not 
      (is_read r) || 
      (( Pset.exists (fun w ->
          is_write w && ((loc_of w = loc_of r) && Pset.mem  (w,r)  hb)) xo.actions ) =
      (Pset.exists (fun w' -> Pset.mem  (w',r)  xw.rf) xo.actions)))) xo.actions

let consistent_non_atomic_rf (xo,xw,("hb",hb)::("vse",vse)::_) =
    Pset.for_all (fun (w,r) -> (not  (is_at_non_atomic_location xo.lk r) || Pset.mem  
      (w,r)  vse)) xw.rf

let consistent_atomic_rf (xo,xw,("hb",hb)::_) =
    Pset.for_all (fun (w,r) -> (not  (is_at_atomic_location xo.lk r) || 
        not ( Pset.mem (r,w)  hb))) xw.rf


let consistent_non_atomic_read_values (xo,xw,("hb",hb)::("vse",vse)::_) =
    Pset.for_all (fun b -> (not 
    (is_read b && is_at_non_atomic_location xo.lk b) || 
      ( if (Pset.exists (fun a_vse -> Pset.mem  (a_vse,b)  vse) xo.actions)
        then (Pset.exists (fun a_vse -> Pset.mem  (a_vse,b)  vse && Pset.mem  (a_vse,b)  xw.rf) xo.actions)
        else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions

let consistent_non_atomic_read_values_rejig (xo,xw,("hb",hb)::("vse",vse)::_) =
    Pset.for_all (fun b -> (not 
    (is_read b && is_at_non_atomic_location xo.lk b) || 
      ( if (Pset.exists (fun w -> Pset.mem  (w,b)  hb && is_write w) xo.actions)
        then (Pset.exists (fun a_vse -> Pset.mem  (a_vse,b)  vse && Pset.mem  (a_vse,b)  xw.rf) xo.actions)
        else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions



let no_vsse_consistent_atomic_read_values (xo,xw,("hb",hb)::("vse",vse)::_) =
    Pset.for_all (fun b -> (not 
    (is_read b && is_at_atomic_location xo.lk b) || 
      ( if (Pset.exists (fun a_vse -> Pset.mem  (a_vse,b)  vse) xo.actions)
        then (Pset.exists (fun a -> ( Pset.mem (a,b)  xw.rf) && not ( Pset.mem (b,a)  hb)) xo.actions)
        else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions



let no_vsse_consistent_atomic_read_values_rejig (xo,xw,("hb",hb)::("vse",vse)::_) =
    Pset.for_all (fun b -> (not 
    (is_read b && is_at_atomic_location xo.lk b) || 
      ( if (Pset.exists (fun w -> Pset.mem  (w,b)  hb && is_write w) xo.actions)
        then (Pset.exists (fun a -> ( Pset.mem (a,b)  xw.rf) && not ( Pset.mem (b,a)  hb)) xo.actions)
        else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions


(* let coherent_memory_use_old (Xo,Xw,("hb",hb)::_) = *)
(*     (* CoRR *) *)
(*     ( forall ((x,a) IN Xw.rf) ((y,b) IN Xw.rf). *)
(*       ((a,b) IN hb && (loc_of a = loc_of b) && is_at_atomic_location Xo.lk b) --> *)
(*       ((x = y) || (x,y) IN Xw.mo) ) && *)
(*     (* CoWR *)     *)
(*     ( forall ((a,b) IN hb) (c IN Xo.actions). *)
(*       ((c,b) IN Xw.rf && is_write a && (loc_of a = loc_of b) && is_at_atomic_location Xo.lk b) --> *)
(*       ((c = a) || (a,c) IN Xw.mo) ) && *)
(*     (* CoRW *) *)
(*     ( forall ((a,b) IN hb) (c IN Xo.actions). *)
(*       ((c,a) IN Xw.rf && is_write b && (loc_of a = loc_of b) && is_at_atomic_location Xo.lk a) --> *)
(*       ((c,b) IN Xw.mo) ) *)

let dummy38' = true

let coherent_memory_use (xo,xw,("hb",hb)::_) =
    (* CoRR *)
    ( not ( Pset.exists (fun (a,b) -> Pset.exists (fun (c,d) -> Pset.mem 
              (b,d)  hb && Pset.mem  (c,a)  xw.mo) xw.rf) xw.rf ) ) &&
    (* CoWR *)    
    (( not ( Pset.exists (fun (a,b) -> Pset.exists (fun c -> Pset.mem 
              (c,b)  hb && Pset.mem  (a,c)  xw.mo) xo.actions) xw.rf ) ) &&
    (* CoRW *)
    (( not ( Pset.exists (fun (a,b) -> Pset.exists (fun c -> Pset.mem 
              (b,c)  hb && Pset.mem  (c,a)  xw.mo) xo.actions) xw.rf ) ) &&
    (* CoRW *)
    ( not (Pset.exists (fun (a,b) -> Pset.mem  (b,a)  xw.mo) hb) )))

let rmw_atomicity (xo,xw,("hb",hb)::_) =
    Pset.for_all (fun (a,b) -> (not 
    (is_RMW b) ||  adjacent_less_than xw.mo xo.actions a b)) xw.rf

let sc_reads_restricted (xo,xw,("hb",hb)::_) =
    Pset.for_all (fun (a,b) -> (not 
      (is_seq_cst b) || 
      (( adjacent_less_than_such_that
          (fun c -> is_write c && (loc_of c = loc_of b)) xw.sc xo.actions a b ) ||
      ( not (is_seq_cst a) &&
        ( Pset.for_all (fun x ->
            (not 
            ( adjacent_less_than_such_that
                (fun c -> is_write c && (loc_of c = loc_of b)) xw.sc xo.actions x b ) ||  not ( Pset.mem (a,x)  hb))) xo.actions ) )))) xw.rf


let sc_fences_heeded (xo,xw,("hb",hb)::_) =
    (* fence restriction N3291 29.3p4 *)
    ( Pset.for_all (fun a -> Pset.for_all (fun (x,b) -> Pset.for_all (fun y -> (not 
      ( is_fence x && (is_atomic_action b &&
        (( adjacent_less_than_such_that
          (fun c -> is_write c && (loc_of c = loc_of b)) xw.sc xo.actions a x ) && Pset.mem 
        (y,b)  xw.rf))) || 
      ((y = a) || Pset.mem  (a,y)  xw.mo))) xo.actions) xo.sb) xo.actions ) &&
    (* fence restriction N3291 29.3p5 *)
    (( Pset.for_all (fun (a,x) -> Pset.for_all (fun (y,b) ->
      ( (not (is_atomic_action a && (is_write a &&
        (is_fence x && (is_atomic_action b && (Pset.mem  (x,b)  xw.sc &&
        (loc_of a = loc_of b)))))) || 
      ((y = a) || Pset.mem  (a,y)  xw.mo)) )) xw.rf) xo.sb ) &&
    (* fence restriction N3291 29.3p6 *)
    (( Pset.for_all (fun (a,x) -> Pset.for_all (fun (y,b) -> Pset.for_all (fun z -> (not 
      ( is_atomic_action a && (is_write a &&
        (is_fence x && (is_fence y && (Pset.mem  (x,y)  xw.sc &&
        (is_atomic_action b && ((loc_of a = loc_of b) && Pset.mem 
        (z,b)  xw.rf))))))) || 
      ((z = a) || Pset.mem  (a,z)  xw.mo))) xo.actions) xo.sb) xo.sb ) &&
    (* SC fences impose mo N3291 29.3p7 *)
    (( Pset.for_all (fun (a,x) -> Pset.for_all (fun (y,b) ->
      ( (not  (is_atomic_action a && (is_write a &&
        (is_atomic_action b && (is_write b &&
        (is_fence x && (is_fence y && (Pset.mem  (x,y)  xw.sc &&
        (loc_of a = loc_of b)))))))) || Pset.mem  
      (a,b)  xw.mo))) xo.sb) xo.sb ) &&
    (* SC fences impose mo N3291 29.3p7, w collapsed first write*)
    (( Pset.for_all (fun a -> Pset.for_all (fun (y,b) ->
      ( (not  (is_atomic_action a && (is_write a &&
        (is_fence y && (Pset.mem  (a,y)  xw.sc &&
        (is_atomic_action b && (is_write b &&
        (loc_of a = loc_of b))))))) || Pset.mem  
      (a,b)  xw.mo))) xo.sb) xo.actions ) &&
    (* SC fences impose mo N3291 29.3p7, w collapsed second write*)
    ( Pset.for_all (fun (a,x) -> Pset.for_all (fun b ->
      ( (not  (is_atomic_action a && (is_write a &&
        (is_fence x && (is_atomic_action b && (is_write b && (Pset.mem  (x,b)  xw.sc &&
        (loc_of a = loc_of b))))))) || Pset.mem  
      (a,b)  xw.mo))) xo.actions) xo.sb )))))





let no_vsse_consistent_rf x =
    consistent_non_atomic_read_values x &&
    (no_vsse_consistent_atomic_read_values x &&
    (coherent_memory_use x &&
    (rmw_atomicity x &&
    (sc_reads_restricted x &&
    sc_fences_heeded x))))


let no_vsse_consistent_rf_rejig x =
    det_read x &&
    (consistent_non_atomic_rf x &&
    (consistent_atomic_rf x &&
    (coherent_memory_use x &&
    (rmw_atomicity x &&
    (sc_reads_restricted x &&
    sc_fences_heeded x)))))




(*********************************************** *)
(*   - 3.9 - Undefined behaviour *)
(*********************************************** *)

let dummy39 = true

let indeterminate_reads (xo,xw,("hb",hb)::_) =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun b x2 -> if is_read b && not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) then Pset.add b x2 else x2) xo.actions x2

let unsequenced_races (xo,xw,("hb",hb)::_) =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
        not (a = b) && ((loc_of a = loc_of b) && ((is_write a || is_write b) &&
        ((tid_of a = tid_of b) &&
        not ( Pset.mem (a,b)  xo.sb || Pset.mem  (b,a)  xo.sb)))) then Pset.add (a,b) x2 else x2) xo.actions x2) xo.actions x2

let data_races (xo,xw,("hb",hb)::_) =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
        not (a = b) && ((loc_of a = loc_of b) && ((is_write a || is_write b) &&
        ((tid_of a <> tid_of b) &&
        (not (is_atomic_action a && is_atomic_action b) &&
        not ( Pset.mem (a,b)  hb || Pset.mem  (b,a)  hb))))) then Pset.add (a,b) x2 else x2) xo.actions x2) xo.actions x2


let good_mutex_use actions lk sb lo a =
    let mutexes_at_l =
      let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a' x2 -> if (is_lock a' || is_unlock a') && (loc_of a' = loc_of a) then Pset.add a' x2 else x2) actions x2
    in
    let lock_order = set_restrict lo mutexes_at_l in
    (* violated requirement: The calling thread shall own the mutex. *)
    ( (not  (is_unlock a) ||  ( Pset.exists (fun al ->
              is_successful_lock al && (Pset.mem  (al,a)  sb &&
              adjacent_less_than lock_order actions al a)) actions )) ) &&
    (* violated requirement: The calling thread does not own the mutex. *)
    ( (not  (is_lock a) || 
      not ( Pset.exists (fun al ->
          is_successful_lock al && ((tid_of a = tid_of al) &&
          adjacent_less_than lock_order actions al a)) actions )) )


let bad_mutexes (xo,xw,("hb",hb)::_) =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if not (good_mutex_use xo.actions xo.lk xo.sb xw.sc a) then Pset.add a x2 else x2) xo.actions x2





let undefined_behaviour =
  [ Two( ("data_races", data_races));
    Two( ("unsequenced_races", unsequenced_races));
    One( ("indeterminate_reads", indeterminate_reads));
    One( ("bad_mutexes", bad_mutexes)) ]



(*********************************************** *)
(* 3.10 - Consistent execution *)
(*********************************************** *)

let dummy310 = true

let no_vsse_relations xo xw =
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.sc rs hrs in
    let cad   = carries_a_dependency_to_set xo.actions xo.sb xo.dd xw.rf in
    let dob   = dependency_ordered_before_set xo.actions xw.rf rs cad in
    let ithb  = inter_thread_happens_before xo.actions xo.sb sw dob in
    let hb    = happens_before xo.actions xo.sb ithb in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("dob", dob);
      ("cad", cad);
      ("sw", sw);
      ("hrs", hrs);
      ("rs", rs) ]

let no_vsse_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_locks", Leaf( consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("consistent_sc", Leaf( consistent_sc));
         ("consistent_mo", Leaf( consistent_mo));
         ("consistent_rf",
           Node( [ ("consistent_non_atomic_read_values",
                     Leaf( consistent_non_atomic_read_values));
                  ("no_vsse_consistent_atomic_read_values",
                     Leaf( no_vsse_consistent_atomic_read_values));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])


let no_vsse_consistent_execution_rejig =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_locks", Leaf( consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("consistent_mo", Leaf( consistent_mo));
         ("consistent_sc", Leaf( consistent_sc));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])



(*********************************************** *)
(*  - 3.12 - Preferred memory_model top level judgement *)
(*********************************************** *)

let dummy312 = true

let no_vsse_memory_model =
  { consistent = no_vsse_consistent_execution;
     relation_calculation = no_vsse_relations;
(*     protocol = true_protocol;*)
     undefined = undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = None;
           ao_flag  = false;
           tot_flag = false }
  }


(*val no_vsse_behaviour : opsem_t -> program -> program_behaviours*)






(*********************************************** <a name="standard">*)
(* 4 - Standard C/C++ memory_model *)
(*********************************************** *)

(* The following definitions make up the memory memory_model described by the
   2011 standard. It was constructed in discussion with the
   standardisation comittee. *)

let dummy4 = true

let visible_sequence_of_side_effects_tail actions mo hb vsse_head b =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun c x2 -> if Pset.mem 
      (vsse_head,c)  mo && (not ( Pset.mem (b,c)  hb) &&
      ( Pset.for_all (fun a -> (not 
          ( Pset.mem (vsse_head,a)  mo && Pset.mem  (a,c)  mo) ||  not ( Pset.mem (b,a)  hb))) actions )) then Pset.add c x2 else x2) actions x2

(* visible sequences of side effects have been proven redundant. See the simpler memory_model in section 3. *)

let visible_sequence_of_side_effects actions lk mo hb vsse_head b =
      (b , if is_at_atomic_location lk b then Pset.union 
             (Pset.from_list Pervasives.compare [vsse_head]) 
             (visible_sequence_of_side_effects_tail actions mo hb vsse_head b)
           else
             Pset.from_list Pervasives.compare [])

let visible_sequences_of_side_effects_set actions lk mo hb vse =
let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun vsse_head x2 -> Pset.fold (fun b x2 -> if 
  is_at_atomic_location lk b && (is_read b &&
  ( Pset.mem (vsse_head,b)  vse)) then Pset.add (visible_sequence_of_side_effects actions lk mo hb vsse_head b) x2 else x2) actions x2) actions x2

let visible_sequence_of_side_effects_relation actions lk mo hb vse =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun b x2 -> Pset.fold (fun v x2 -> Pset.fold (fun vsse_head x2 -> if
    is_at_atomic_location lk b && (is_read b && (( Pset.mem (vsse_head,b)  vse) &&
    (v = vsse_head || Pset.mem  v  (visible_sequence_of_side_effects_tail actions mo hb vsse_head b)))) then Pset.add (v,b) x2 else x2) actions x2) actions x2) actions x2



let relations xo xw =
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.sc rs hrs in
    let cad   = carries_a_dependency_to_set xo.actions xo.sb xo.dd xw.rf in
    let dob   = dependency_ordered_before_set xo.actions xw.rf rs cad in
    let ithb  = inter_thread_happens_before xo.actions xo.sb sw dob in
    let hb    = happens_before xo.actions xo.sb ithb in
    let vse   = visible_side_effect_set xo.actions hb in
    let vsses = visible_sequence_of_side_effects_relation xo.actions xo.lk xw.mo hb vse in
    [ ("hb", hb);
      ("vse", vse);
      ("vsses", vsses);
      ("ithb", ithb);
      ("dob", dob);
      ("cad", cad);
      ("sw", sw);
      ("hrs", hrs);
      ("rs", rs) ]


let consistent_atomic_read_values_old (xo,xw,("hb",hb)::("vse",vse)::("vsses",vsses)::_) =
    Pset.for_all (fun b -> (not 
    (is_read b && is_at_atomic_location xo.lk b) || 
      ( if (Pset.exists (fun (b',v) -> b = b') vsses)
        then ( Pset.exists (fun (b',v) -> b = b' &&
               (Pset.exists (fun c -> Pset.mem  (c,b)  xw.rf) v)) vsses )
        else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions


let consistent_atomic_read_values (xo,xw,("hb",hb)::("vse",vse)::("vsses",vsses)::_) =
    Pset.for_all (fun b -> (not 
    (is_read b && is_at_atomic_location xo.lk b) || 
      ( if (Pset.exists (fun v -> Pset.mem  (v,b)  vsses) xo.actions)
        then ( Pset.exists (fun v' -> Pset.mem  (v',b)  vsses && Pset.mem  (v',b)  xw.rf) xo.actions )
        else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions


let consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("consistent_locks", Leaf( consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("consistent_sc", Leaf( consistent_sc));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("consistent_non_atomic_read_values",
                     Leaf( consistent_non_atomic_read_values));
                  ("consistent_atomic_read_values",
                     Leaf( consistent_atomic_read_values));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])


(*********************************************** *)
(*   - 4.1  - Standard memory_model top level judgement *)
(*********************************************** *)

let dummy41 = true

let cmm_memory_model =
  { consistent = consistent_execution;
     relation_calculation = relations;
(*     protocol = true_protocol;*)
     undefined = undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = None;
           ao_flag  = false;
           tot_flag = false }
  }


(*val cmm_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 5 - Memory_Model with separate lock order *)
(*********************************************** *)

(* A version of the no VSSE memory_model with a separate lock order. *)

let dummy5 = true

let separate_lo_consistent_sc (xo,xw,("hb",hb)::_) =
    let all_sc_actions =
      let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if is_seq_cst a then Pset.add a x2 else x2) xo.actions x2 in
    let sc_happens_before = set_restrict hb (all_sc_actions) in
    let sc_mod_order =
      set_restrict xw.mo all_sc_actions in
    strict_total_order_over all_sc_actions xw.sc && (Pset.subset 
    sc_happens_before  xw.sc && Pset.subset 
    sc_mod_order  xw.sc)


let separate_lo_consistent_lo (xo,xw,("hb",hb)::_) =
    let all_lo_actions =
      let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if is_lock a || is_unlock a then Pset.add a x2 else x2) xo.actions x2 in
    let lo_happens_before = set_restrict hb all_lo_actions in
    strict_total_order_over all_lo_actions xw.lo && Pset.subset 
    lo_happens_before  xw.lo



let separate_lo_consistent_locks (xo,xw,("hb",hb)::_) =
    (Pset.for_all (fun (a,c) ->
      (not  
      (is_successful_lock a && (is_successful_lock c && (loc_of a = loc_of c))) ||  
      (Pset.exists (fun b -> (loc_of a = loc_of b) && (is_unlock b && (Pset.mem  (a,b)  xw.lo && Pset.mem  (b,c)  xw.lo))) xo.actions))) xw.lo)


let no_vsse_separate_lo_relations xo xw =
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs in
    let cad   = carries_a_dependency_to_set xo.actions xo.sb xo.dd xw.rf in
    let dob   = dependency_ordered_before_set xo.actions xw.rf rs cad in
    let ithb  = inter_thread_happens_before xo.actions xo.sb sw dob in
    let hb    = happens_before xo.actions xo.sb ithb in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("dob", dob);
      ("cad", cad);
      ("sw", sw);
      ("hrs", hrs);
      ("rs", rs) ]



let separate_lo_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("separate_lo_consistent_locks",
            Leaf( separate_lo_consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("separate_lo_consistent_sc", Leaf( separate_lo_consistent_sc));
         ("separate_lo_consistent_lo", Leaf( separate_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])




let separate_lo_bad_mutexes (xo,xw,("hb",hb)::_) =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if not (good_mutex_use xo.actions xo.lk xo.sb xw.lo a) then Pset.add a x2 else x2) xo.actions x2


let separate_lo_undefined_behaviour =
  [ Two( ("data_races", data_races));
    Two( ("unsequenced_races", unsequenced_races));
    One( ("indeterminate_reads", indeterminate_reads));
    One( ("separate_lo_bad_mutexes", separate_lo_bad_mutexes)) ]



(*********************************************** *)
(*  - 5.1  - Separate lock order top level judgement *)
(*********************************************** *)

let dummy51 = true

let separate_lo_memory_model =
  { consistent = separate_lo_consistent_execution;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_calculation = no_vsse_separate_lo_relations;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Global_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val separate_lo_behaviour : opsem_t -> program -> program_behaviours*)





(*********************************************** *)
(* 6 - Memory_Model with per-location lock orders *)
(*********************************************** *)

(* This memory_model uses per-location lock orders rather than a shared one. *)

let dummy6 = true

let multi_lo_consistent_lo (xo,xw,("hb",hb)::_) =
    let mutex_actions =
      let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if is_lock a || is_unlock a then Pset.add a x2 else x2) xo.actions x2 in
    let mutex_hb = set_restrict hb mutex_actions in
    relation_over mutex_actions xw.lo &&
    (locationwise mutex_actions xw.lo &&
    (strict_partial_order mutex_actions xw.lo &&
    (per_location_total mutex_actions xw.lo && Pset.subset 
    mutex_hb  xw.lo)))


let multi_lo_consistent_locks (xo,xw,("hb",hb)::_) =
    (Pset.for_all (fun (a,c) ->
      (not  
      (is_successful_lock a && is_successful_lock c) ||  
      (Pset.exists (fun b -> is_unlock b && (Pset.mem  (a,b)  xw.lo && Pset.mem  (b,c)  xw.lo)) xo.actions))) xw.lo)



let multi_lo_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("multi_lo_consistent_locks", Leaf( multi_lo_consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("separate_lo_consistent_sc", Leaf( separate_lo_consistent_sc));
         ("multi_lo_consistent_lo", Leaf( multi_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])



(*********************************************** *)
(*   - 6.1  - per-location lock order top level judgement *)
(*********************************************** *)

let dummy61 = true

let multi_lo_memory_model =
  { consistent = multi_lo_consistent_execution;
     relation_calculation = no_vsse_separate_lo_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val multi_lo_behaviour : opsem_t -> program -> program_behaviours*)










(*********************************************** *)
(* 6a - Memory_Model with per-location lock orders and sc coherence *)
(*********************************************** *)

let dummy6a = true

let sc_coherent (xo,xw,("hb",hb)::_) =
    (* CoRR *)
    ( not
      ( Pset.exists (fun (x,a) -> Pset.exists (fun (y,b) ->
          (loc_of a = loc_of b) && (is_at_atomic_location xo.lk b && (Pset.mem 
          (a,b)  xw.sc && Pset.mem 
          (x,y)  xw.mo))) xw.rf) xw.rf ) ) &&
    (* CoWR *)    
    (( not
      ( Pset.exists (fun (x,a) -> Pset.exists (fun (y,b) ->
          (loc_of a = loc_of b) && (is_at_atomic_location xo.lk b && (Pset.mem 
          (a,b)  xw.sc && Pset.mem 
          (x,y)  xw.mo))) xw.rf) xw.rf ) ) &&
    (* CoRW *)
    (( not
      ( Pset.exists (fun (a,b) -> Pset.exists (fun c ->
          (loc_of a = loc_of b) && (is_at_atomic_location xo.lk a && (Pset.mem 
          (c,a)  xw.rf && Pset.mem 
          (c,b)  xw.mo))) xo.actions) xw.sc ) ) &&
    (* CoRR *)
    (( not
      ( Pset.exists (fun (x,a) -> Pset.exists (fun (y,b) ->
          (loc_of a = loc_of b) && (is_at_atomic_location xo.lk b && (Pset.mem 
          (a,b)  hb && Pset.mem 
          (x,y)  xw.sc))) xw.rf) xw.rf ) ) &&
    (* CoWR *)    
    (( not
      ( Pset.exists (fun (x,a) -> Pset.exists (fun (y,b) ->
          (loc_of a = loc_of b) && (is_at_atomic_location xo.lk b && (Pset.mem 
          (a,b)  hb && Pset.mem 
          (x,y)  xw.sc))) xw.rf) xw.rf ) ) &&
    (* CoRW *)
    ( not
      ( Pset.exists (fun (a,b) -> Pset.exists (fun c ->
          (loc_of a = loc_of b) && (is_at_atomic_location xo.lk a && (Pset.mem 
          (c,a)  xw.rf && Pset.mem 
          (c,b)  xw.sc))) xo.actions) hb ) )))))





let sc_coherent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("multi_lo_consistent_locks", Leaf( multi_lo_consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("separate_lo_consistent_sc", Leaf( separate_lo_consistent_sc));
         ("multi_lo_consistent_lo", Leaf( multi_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ]));
         ("sc_coherent", Leaf( sc_coherent)) ])



(*********************************************** *)
(*   - 6a.1  - sc coherent top level judgement *)
(*********************************************** *)

let dummy6a1 = true

let sc_coherent_memory_model =
  { consistent = sc_coherent_execution;
     relation_calculation = no_vsse_separate_lo_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val sc_coherent_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 6b - Memory_Model with per-location lock orders and strong coherence *)
(*********************************************** *)

let dummy6b = true

let strong_coherence (xo,xw,("hb",hb)::_) =
    let fr = let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if Pset.exists (fun c -> ( Pset.mem (c,a)  xw.rf) && ( Pset.mem (c,b)  xw.mo)) xo.actions then Pset.add (a,b) x2 else x2) xo.actions x2) xo.actions x2 in
    irrefl xo.actions (tc
      ( compose xw.sc ( Pset.union (Pset.union (Pset.union (Pset.union    xw.sc  xw.mo)  xw.rf)  hb)  fr) ))


let strong_coherence_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("multi_lo_consistent_locks", Leaf( multi_lo_consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("separate_lo_consistent_sc", Leaf( separate_lo_consistent_sc));
         ("multi_lo_consistent_lo", Leaf( multi_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
(*                ("coherent_memory_use", Leaf coherent_memory_use);*)
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ]));
         ("strong_coherence", Leaf( strong_coherence)) ])



(*********************************************** *)
(*   - 6b.1  - strong coherence top level judgement *)
(*********************************************** *)

let dummy6b1 = true

let strong_coherence_memory_model =
  { consistent = strong_coherence_execution;
     relation_calculation = no_vsse_separate_lo_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val strong_coherence_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 7 - Memory_Model with per-location lock orders and sc order *)
(*********************************************** *)

(* This memory_model uses per location lock orders rather than one shared one. *)

let dummy7 = true

let multi_sc_consistent_sc (xo,xw,("hb",hb)::_) =
    let all_sc_actions =
      let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if is_seq_cst a then Pset.add a x2 else x2) xo.actions x2 in
    let sc_happens_before = set_restrict hb all_sc_actions in
    let sc_mod_order = set_restrict xw.mo all_sc_actions in
    relation_over all_sc_actions xw.sc &&
    (locationwise all_sc_actions xw.sc &&
    (strict_partial_order all_sc_actions xw.sc &&
    (per_location_total all_sc_actions xw.sc && (Pset.subset 
    sc_happens_before  xw.sc && Pset.subset 
    sc_mod_order  xw.sc))))




let multi_sc_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("multi_lo_consistent_locks",
            Leaf( multi_lo_consistent_locks));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("multi_sc_consistent_sc", Leaf( multi_sc_consistent_sc));
         ("multi_lo_consistent_lo", Leaf( multi_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])







(*********************************************** *)
(*   - 7.1  - per-location lock order top level judgement *)
(*********************************************** *)

let dummy71 = true

let multi_sc_memory_model =
  { consistent = multi_sc_consistent_execution;
     relation_calculation = no_vsse_separate_lo_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }



(*val multi_sc_behaviour : opsem_t -> program -> program_behaviours*)


(*********************************************** *)
(* 8 - Memory_Model with single step mutex synchronisation *)
(*********************************************** *)

(* This memory_model creates synchronizes-with edges from each unlock to the *)
(*    next lock at the same location, rather than all subsequent ones. *)

let dummy8 = true

let lo_single_synchronizes_with actions sb asw rf lo rs hrs a b = Pset.mem 
    (* thread sync *)
    (a,b)  asw ||
    ( (loc_of a = loc_of b) && (Pset.mem  a  actions && (Pset.mem  b  actions &&
      ( (* mutex sync *)
        (is_unlock a && (is_successful_lock b && (Pset.mem  (a,b)  lo && not (Pset.exists (fun c -> Pset.mem  (a,c)  lo && Pset.mem  (c,b)  lo) actions)))) ||
        (* rel/acq sync *)
        (( is_release a && (is_acquire b && ((tid_of a <> tid_of b) &&
          (Pset.exists (fun c -> Pset.mem  (a,c)  rs && Pset.mem  (c,b)  rf) actions ))) ) ||
        (* fence sync *)
        (( (tid_of a <> tid_of b) &&
          (is_fence a && (is_release a && (is_fence b && (is_acquire b &&
          ( Pset.exists (fun x -> Pset.exists (fun y -> (loc_of x = loc_of y) &&
              (is_atomic_action x && (is_atomic_action y && (is_write x && (Pset.mem 
              (a,x)  sb && (Pset.mem  (y,b)  sb &&
              ( Pset.exists (fun z -> Pset.mem  (x,z)  hrs && Pset.mem  (z,y)  rf) actions))))))) actions) actions ))))) ) ||
        (( (tid_of a <> tid_of b) &&
          (is_fence a && (is_release a && (is_atomic_action b && (is_acquire b &&
          ( Pset.exists (fun x -> (loc_of x = loc_of b) &&
            (is_atomic_action x && (is_write x && (Pset.mem  (a,x)  sb &&
            ( Pset.exists (fun z -> Pset.mem  (x,z)  hrs && Pset.mem  (z,b)  rf) actions ))))) actions ))))) ) ||
        ( (tid_of a <> tid_of b) &&
          (is_atomic_action a && (is_release a &&
          (is_fence b && (is_acquire b &&
          ( Pset.exists (fun x -> (loc_of a = loc_of x) && (is_atomic_action x && (Pset.mem 
            (x,b)  sb &&
            ( Pset.exists (fun z -> Pset.mem  (a,z)  rs && Pset.mem  (z,x)  rf) actions )))) actions ))))) )))) ))) )


let lo_single_synchronizes_with_set actions sb asw rf lo rs hrs =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       lo_single_synchronizes_with actions sb asw rf lo rs hrs a b then Pset.add (a,b) x2 else x2) actions x2) actions x2



let lo_single_relations xo xw =
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = lo_single_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs in
    let cad   = carries_a_dependency_to_set xo.actions xo.sb xo.dd xw.rf in
    let dob   = dependency_ordered_before_set xo.actions xw.rf rs cad in
    let ithb  = inter_thread_happens_before xo.actions xo.sb sw dob in
    let hb    = happens_before xo.actions xo.sb ithb in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("dob", dob);
      ("cad", cad);
      ("sw", sw);
      ("hrs", hrs);
      ("rs", rs) ]



(*********************************************** *)
(*   - 8.1  - single step mutex synchronisation top level judgement *)
(*********************************************** *)

let dummy81 = true

let lo_single_memory_model =
  { consistent = multi_sc_consistent_execution;
     relation_calculation = lo_single_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }




(*val lo_single_behaviour : opsem_t -> program -> program_behaviours*)


(*********************************************** *)
(* 9 - Memory_Model simplified for programs without consumes *)
(*********************************************** *)

(* This memory_model is simplified for use with programs that don't use *)
(*    consume memory orders. Happens-before is transitive. *)

let dummy9 = true

let no_consume_hb sb sw =
    tc ( Pset.union sb  sw)


let no_consume_relations xo xw =
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = lo_single_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs in
    let hb    = no_consume_hb xo.sb sw in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("hrs", hrs);
      ("rs", rs) ]


let no_consume_consistent_hb (xo,xw,("hb",hb)::_) =
    irrefl xo.actions hb


let no_consume_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("multi_lo_consistent_locks", Leaf( multi_lo_consistent_locks));
         ("no_consume_consistent_hb", Leaf( no_consume_consistent_hb));
         ("multi_sc_consistent_sc", Leaf( multi_sc_consistent_sc));
         ("multi_lo_consistent_lo", Leaf( multi_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])



(*********************************************** *)
(*   - 9.1  - No consume top level judgement *)
(*********************************************** *)

let dummy91 = true

let no_consume_memory_model =
  { consistent = no_consume_consistent_execution;
     relation_calculation = no_consume_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val no_consume_behaviour : opsem_t -> program -> program_behaviours*)


(*********************************************** *)
(* 10 - Memory_Model simplified for programs without consumes or relaxed *)
(*********************************************** *)

(* Without relaxed, can release sequences go? Unfortunately not. This
memory_model is NOT equivalent without the extra condition that
initialisation of atomics happen-before all accesses of that atomic.
The reason is that non-atomic initialisation can be one of the writes
in the release sequence that immediately precedes an RMW. Then in this
memory_model, there is no hb from the release to the read of the RMW, but
there is in the preferred memory_model. Then we can construct an execution
with a race in the preffered memory_model that is inconsitent on this
memory_model. *)

let dummy10 = true

let rel_acq_sc_synchronizes_with actions sb asw rf lo a b = Pset.mem 
    (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && (is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    ( is_release a && (is_acquire b && ((tid_of a <> tid_of b) && Pset.mem  (a,b)  rf)) ))


let rel_acq_sc_synchronizes_with_set actions sb asw rf lo =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       rel_acq_sc_synchronizes_with actions sb asw rf lo a b then Pset.add (a,b) x2 else x2) actions x2) actions x2


let rel_acq_sc_relations xo xw =
    let sw    = rel_acq_sc_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo in
    let hb    = no_consume_hb xo.sb sw in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw) ]



let rel_acq_sc_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("multi_lo_consistent_locks", Leaf( multi_lo_consistent_locks));
         ("no_consume_consistent_hb", Leaf( no_consume_consistent_hb));
         ("multi_sc_consistent_sc", Leaf( multi_sc_consistent_sc));
         ("multi_lo_consistent_lo", Leaf( multi_lo_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read",
                     Leaf( det_read));
                  ("consistent_non_atomic_rf",
                     Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf",
                     Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_reads_restricted", Leaf( sc_reads_restricted));
                  ("sc_fences_heeded", Leaf( sc_fences_heeded)) ])) ])





let not_rel_acq_sc (xo,xw,("hb",hb)::_) =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if 
    (match a with
    | Lock( _, _, _, _)            -> false
    | Unlock( _, _, _)            -> false
    | Load( _, _, mo, _, _)         -> not ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire]))
    | Store( _, _, mo, _, _)        -> not ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release]))
    | RMW( _, _, mo, _, _, _)        -> mo <> Acq_rel
    | Fence( _, _, _)             -> true
    | Blocked_rmw( _, _, _)       -> false
    ) then Pset.add a x2 else x2) xo.actions x2


let rel_acq_sc_undefined_behaviour =
  [ Two( ("data_races", data_races));
    Two( ("unsequenced_races", unsequenced_races));
    One( ("indeterminate_reads", indeterminate_reads));
    One( ("separate_lo_bad_mutexes", separate_lo_bad_mutexes));
    One( ("not_rel_acq_sc", not_rel_acq_sc))
 ]


(*********************************************** *)
(*   - 10.1  - No consume or relaxed top level judgement *)
(*********************************************** *)

let dummy101 = true

let rel_acq_sc_memory_model =
  { consistent = rel_acq_sc_consistent_execution;
     relation_calculation = rel_acq_sc_relations;
(*     protocol = true_protocol;*)
     undefined = rel_acq_sc_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
    mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val rel_acq_sc_behaviour : opsem_t -> program -> program_behaviours*)




(*********************************************** <a name="tot">*)
(* 11 - Memory_Model simplified for programs without consumes, relaxed, acquires or releases *)
(*********************************************** *)

let dummy11 = true

let tot_relations xo xw =
    let sw    = rel_acq_sc_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.tot in
    let hb    = no_consume_hb xo.sb sw in
    [ ("hb", hb);
      ("sw", sw) ]




let tot_consistent_total_order (xo,xw,_) =
  strict_total_order_over xo.actions xw.tot && (Pset.subset 
  xo.sb  xw.tot && Pset.subset 
  xo.asw  xw.tot)


(* NOTE: This predicate should be simplified. *)
let tot_consistent_read_values (xo,xw,_) =
  (Pset.for_all (fun b -> (not 
    (is_read b) || 
    ( let writes_at_same_location = let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if (loc_of a = loc_of b) && is_write a then Pset.add a x2 else x2) xo.actions x2 in
      if (Pset.exists (fun a ->
        adjacent_less_than (set_restrict xw.tot ( Pset.union writes_at_same_location  (Pset.from_list Pervasives.compare [b]))) xo.actions a b) xo.actions)
      then (Pset.exists (fun a ->
        ( Pset.mem (a,b)  xw.rf) &&
        adjacent_less_than (set_restrict xw.tot ( Pset.union writes_at_same_location  (Pset.from_list Pervasives.compare [b]))) xo.actions a b) xo.actions)
      else not (Pset.exists (fun a -> Pset.mem  (a,b)  xw.rf) xo.actions) ))) xo.actions )



let tot_consistent_locks (xo,xw,_) =
    (Pset.for_all (fun (a,c) ->
      (not  
      (is_successful_lock a && (is_successful_lock c && (loc_of a = loc_of c))) || 
      (Pset.exists (fun b -> (loc_of a = loc_of b) && (is_unlock b && (Pset.mem  (a,b)  xw.tot && Pset.mem  (b,c)  xw.tot))) xo.actions))) xw.tot)



let tot_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("tot_consistent_locks", Leaf( tot_consistent_locks));
         ("tot_consistent_total_order", Leaf( tot_consistent_total_order));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("tot_consistent_read_values", Leaf( tot_consistent_read_values)) ])

(* NOTE: Could the definition of data race be made into the traditional total-order adjacency formulation and be shown to be equivalent? *)

(*********************************************** *)
(*   - 11.1  - No consume, relaxed, acquire or release top level judgement *)
(*********************************************** *)

let dummy111 = true

let tot_memory_model =
  { consistent = tot_consistent_execution;
     relation_calculation = tot_relations;
(*     protocol = true_protocol;*)
     undefined = separate_lo_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = false;
           sc_flag  = false;
           lo_flag  = None;
           ao_flag  = false;
           tot_flag = true }
  }


(*val tot_behaviour : opsem_t -> program -> program_behaviours*)




(*********************************************** *)
(* 13 - Memory_Model simplified, single thread, no atomics 2 *)
(*********************************************** *)

let dummy13 = true

let single_thread_relations xo xw =
    let hb    = xo.sb in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse) ]

let single_thread_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf)) ])) ])


(*********************************************** *)
(*   - 13.1  - top level judgement *)
(*********************************************** *)

let dummy131 = true

let single_thread_undefined_behaviour =
  [ Two( ("unsequenced_races", unsequenced_races));
    One( ("indeterminate_reads", indeterminate_reads)) ]

(*val single_thread_protocol : protocol_t*)
let single_thread_protocol (xo,_,_) =
  Pset.exists (fun t -> xo.threads = Pset.from_list Pervasives.compare [t] &&
  Pset.for_all (fun a -> is_NA_load a || is_NA_store a) xo.actions) xo.threads


let single_thread_memory_model =
  { consistent = single_thread_consistent_execution;
     relation_calculation = single_thread_relations;
(*     protocol = single_thread_protocol;*)
     undefined = single_thread_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = false;
           sc_flag  = false;
           lo_flag  = None;
           ao_flag  = false;
           tot_flag = false }
  }


(*val single_thread_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 14 - Memory_Model simplified, multi-thread, no atomics, yes locks *)
(*********************************************** *)

let dummy14 = true

let locks_only_sw actions asw lo a b =
  (tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    (is_unlock a && (is_successful_lock b && Pset.mem  (a,b)  lo))
  )

let locks_only_sw_set actions asw lo =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       locks_only_sw actions asw lo a b then Pset.add (a,b) x2 else x2) actions x2) actions x2

let locks_only_hb xo xw =
    let sw = locks_only_sw_set xo.actions xo.asw xw.lo in
    tc ( Pset.union xo.sb  sw)


let locks_only_relations xo xw =
    let sw    = locks_only_sw_set xo.actions xo.asw xw.lo in
    let hb    = no_consume_hb xo.sb sw in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw) ]





(* let locks_only_consistent_lo_old (Xo,Xw,("hb",hb)::_) = *)
(*     let mutex_actions = *)
(*       { a | forall (a IN Xo.actions) | is_lock a || is_unlock a } in *)
(*     strict_partial_order mutex_actions Xw.lo && *)
(*     per_location_total mutex_actions Xw.lo && *)
(*     forall ((a,b) IN Xw.lo). *)
(*       a IN mutex_actions && b IN mutex_actions && *)
(*       (loc_of a = loc_of b) && *)
(*       not ((b,a) IN hb) *)

let dummy14' = true

let locks_only_consistent_lo (xo,xw,("hb",hb)::_) =
    trans xo.actions xw.lo &&
    (irrefl xo.actions xw.lo &&
    Pset.for_all (fun a -> Pset.for_all (fun b -> (not (Pset.mem  
      (a,b)  xw.lo) ||  (not ( Pset.mem (b,a)  hb) &&
      (( Pset.mem (a,b)  xw.lo || Pset.mem  (b,a)  xw.lo)
      = ( (is_lock a || is_unlock a) && ((is_lock b || is_unlock b) &&
          ((loc_of a = loc_of b) &&
          is_at_mutex_location xo.lk a)) ))))) xo.actions) xo.actions)



let locks_only_consistent_locks (xo,xw,("hb",hb)::_) =
    (Pset.for_all (fun (a,c) ->
      (not  
      (is_successful_lock a && is_successful_lock c) ||  
      (Pset.exists (fun b -> is_unlock b && (Pset.mem  (a,b)  xw.lo && Pset.mem  (b,c)  xw.lo)) xo.actions))) xw.lo)


let locks_only_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf)) ])) ])


(*********************************************** *)
(*   - 14.1  - lock only undefined behaviour *)
(*********************************************** *)

let dummy141 = true

let locks_only_good_mutex_use actions lk sb lo a =
    (* violated requirement: The calling thread shall own the mutex. *)
    ( (not  (is_unlock a) || 
        ( Pset.exists (fun al ->
            is_successful_lock al && (Pset.mem  (al,a)  sb &&
            adjacent_less_than lo actions al a)) actions )) ) &&
    (* violated requirement: The calling thread does not own the mutex. *)
    ( (not  (is_lock a) || 
      not ( Pset.exists (fun al ->
              is_successful_lock al && (Pset.mem  (al,a)  sb &&
              adjacent_less_than lo actions al a)) actions )) )


let locks_only_bad_mutexes (xo,xw,_) =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> if
    not (locks_only_good_mutex_use xo.actions xo.lk xo.sb xw.lo a) then Pset.add a x2 else x2) xo.actions x2


let locks_only_undefined_behaviour =
  [ Two( ("unsequenced_races", unsequenced_races));
    Two( ("data_races", data_races));
    One( ("indeterminate_reads", indeterminate_reads));
    One( ("locks_only_bad_mutexes", locks_only_bad_mutexes)) ]


(*********************************************** *)
(*   - 14.2  - top level judgement *)
(*********************************************** *)

let dummy142 = true

(*val locks_only_protocol : protocol_t*)
let locks_only_protocol (xo,_,_) =
  Pset.for_all (fun a ->
    is_NA_load a || (is_NA_store a || (is_lock a || is_unlock a))) xo.actions


let locks_only_memory_model =
  { consistent = locks_only_consistent_execution;
     relation_calculation = locks_only_relations;
(*     protocol = locks_only_protocol;*)
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = false;
           sc_flag  = false;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }

(*val locks_only_behaviour : opsem_t -> program -> program_behaviours*)





(*********************************************** *)
(* 14a - relaxed - memory_model simplified for programs without sc,
consumes, release or acquire *)
(*********************************************** *)

let dummy14a = true

let relaxed_only_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity)) ])) ])


(*val relaxed_only_protocol : protocol_t*)
let relaxed_only_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> mo = Relaxed
      | Store( _, _, mo, _, _)        -> mo = Relaxed
      | RMW( _, _, mo, _, _, _)        -> mo = Relaxed
      | Fence( _, _, _)             -> false
      | Blocked_rmw( _, _, _)       -> true )) xo.actions




(*********************************************** *)
(*   - 14a.1  - relaxed-only top level judgement *)
(*********************************************** *)

let dummy14a1 = true

let relaxed_only_memory_model =
  { consistent = relaxed_only_consistent_execution;
     relation_calculation = locks_only_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val relaxed_only_behaviour : opsem_t -> program -> program_behaviours*)






(*********************************************** *)
(* 15 - release acquire - memory_model simplified for programs without sc,
consumes or relaxed *)
(*********************************************** *)

let dummy15 = true

(*val release_acquire_protocol : protocol_t*)
let release_acquire_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire]))
      | Store( _, _, mo, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release]))
      | RMW( _, _, mo, _, _, _)        -> mo = Acq_rel
      | Fence( _, _, _)             -> false
      | Blocked_rmw( _, _, _)       -> true )) xo.actions


let release_acquire_synchronizes_with actions sb asw rf lo a b =
  (tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && (is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    ( is_release a && (is_acquire b && Pset.mem  (a,b)  rf) ))
  )

let release_acquire_synchronizes_with_set actions sb asw rf lo =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       release_acquire_synchronizes_with actions sb asw rf lo a b then Pset.add (a,b) x2 else x2) actions x2) actions x2

let release_acquire_relations xo xw =
    let sw    = release_acquire_synchronizes_with_set
                  xo.actions xo.sb xo.asw xw.rf xw.lo in
    let hb    = no_consume_hb xo.sb sw in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw) ]



(*********************************************** *)
(*   - 15.1  - release acquire top level judgement *)
(*********************************************** *)

let dummy151 = true

let release_acquire_memory_model =
  { consistent = relaxed_only_consistent_execution;
     relation_calculation = release_acquire_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val release_acquire_behaviour : opsem_t -> program -> program_behaviours*)


(*********************************************** *)
(* 15a - release_acquire_relaxed - memory_model simplified for programs without sc,
consumes or relaxed *)
(*********************************************** *)

let dummy15a = true

(*val release_acquire_relaxed_protocol : protocol_t*)
let release_acquire_relaxed_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed]))
      | Store( _, _, mo, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release;Relaxed]))
      | RMW( _, _, mo, _, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [Acq_rel;Acquire;Release;Relaxed]))
      | Fence( _, _, _)             -> false
      | Blocked_rmw( _, _, _)       -> true )) xo.actions


let release_acquire_relaxed_synchronizes_with actions sb asw rf lo rs a b =
  (tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && (is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    ( is_release a && (is_acquire b &&
      (Pset.exists (fun c -> Pset.mem  (a,c)  rs && Pset.mem  (c,b)  rf) actions)) ))
  )

let release_acquire_relaxed_synchronizes_with_set actions sb asw rf lo rs =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       release_acquire_relaxed_synchronizes_with actions sb asw rf lo rs a b then Pset.add (a,b) x2 else x2) actions x2) actions x2

let release_acquire_relaxed_relations xo xw =
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = release_acquire_relaxed_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs in
    let hb    = no_consume_hb xo.sb sw in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("rs", rs) ]




(*********************************************** *)
(*   - 15a.1  - release acquire relaxed top level judgement *)
(*********************************************** *)

let dummy15a1 = true

let release_acquire_relaxed_memory_model =
  { consistent = relaxed_only_consistent_execution;
     relation_calculation = release_acquire_relaxed_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val release_acquire_relaxed_behaviour : opsem_t -> program -> program_behaviours*)




(*********************************************** *)
(* 15b - release_acquire_fenced *)
(*********************************************** *)

let dummy15b = true

(*val release_acquire_fenced_protocol : protocol_t*)
let release_acquire_fenced_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed]))
      | Store( _, _, mo, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release;Relaxed]))
      | RMW( _, _, mo, _, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [Acq_rel;Acquire;Release;Relaxed]))
      | Fence( _, _, mo)            -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed]))
      | Blocked_rmw( _, _, _)       -> true )) xo.actions


let release_acquire_fenced_synchronizes_with actions sb asw rf lo rs hrs a b =
  (tid_of a <> tid_of b) &&
  ( Pset.mem  (* thread sync *)
    (a,b)  asw ||
    (* mutex sync *)
    ((is_unlock a && (is_successful_lock b && Pset.mem  (a,b)  lo)) ||
    (* rel/acq sync *)
    (( is_release a && (is_acquire b &&
      (Pset.exists (fun c -> Pset.mem  (a,c)  rs && Pset.mem  (c,b)  rf) actions)) ) ||
    (* fence synchronisation *)
    (( is_fence a && (is_release a && (is_fence b && (is_acquire b &&
      Pset.exists (fun x -> Pset.exists (fun y -> Pset.exists (fun z -> Pset.mem 
        (a,x)  sb && (Pset.mem  (x,y)  hrs && (Pset.mem  (y,z)  rf && Pset.mem  (y,b)  sb))) actions) actions) actions)))) ||
    (( is_fence a && (is_release a && (is_acquire b &&
      Pset.exists (fun x -> Pset.exists (fun y -> Pset.mem 
          (a,x)  sb && (Pset.mem  (x,y)  hrs && Pset.mem  (y,b)  rf)) actions) actions)) ) ||
    ( is_release a && (is_fence b && (is_acquire b &&
      Pset.exists (fun x -> Pset.exists (fun y -> Pset.mem 
        (a,x)  rs && (Pset.mem  (x,y)  rf && Pset.mem  (y,b)  sb)) actions) actions))))))) )


let release_acquire_fenced_synchronizes_with_set actions sb asw rf lo rs hrs =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       release_acquire_fenced_synchronizes_with actions sb asw rf lo rs hrs a b then Pset.add (a,b) x2 else x2) actions x2) actions x2

let release_acquire_fenced_relations xo xw =
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = release_acquire_fenced_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs in
    let hb    = no_consume_hb xo.sb sw in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs) ]



(*********************************************** *)
(*   - 15b.1  - release acquire fenced top level judgement *)
(*********************************************** *)

let dummy15b1 = true

let release_acquire_fenced_memory_model =
  { consistent = relaxed_only_consistent_execution;
     relation_calculation = release_acquire_fenced_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = false;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val release_acquire_fenced_behaviour : opsem_t -> program -> program_behaviours*)





(*********************************************** *)
(* 15c - sc, no sc fences *)
(*********************************************** *)

let dummy15c = true

(*val sc_accesses_protocol : protocol_t*)
let sc_accesses_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed;Seq_cst]))
      | Store( _, _, mo, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release;Relaxed;Seq_cst]))
      | RMW( _, _, mo, _, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [Acq_rel;Acquire;Release;Relaxed;Seq_cst]))
      | Fence( _, _, mo)            -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed]))
      | Blocked_rmw( _, _, _)       -> true )) xo.actions



let sc_accesses_consistent_sc (xo,xw,("hb",hb)::_) =
    trans xo.actions xw.sc &&
    (irrefl xo.actions xw.sc &&
    Pset.for_all (fun a -> Pset.for_all (fun b -> (not (Pset.mem  
      (a,b)  xw.sc) ||  (not ( Pset.mem (b,a) (Pset.union   hb  xw.mo)) &&
      (( Pset.mem (a,b)  xw.sc || Pset.mem  (b,a)  xw.sc) = (is_seq_cst a && is_seq_cst b))))) xo.actions) xo.actions)

(* let sc_accesses_consistent_sc_old (Xo,Xw,("hb",hb)::_) = *)
(*     trans Xo.actions Xw.sc && *)
(*     irrefl Xo.actions Xw.sc && *)
(*     forall (a IN Xo.actions) (b IN Xo.actions). *)
(*       (is_seq_cst a && is_seq_cst b) = ((a,b) IN Xw.sc || (b,a) IN Xw.sc) && *)
(*       (a,b) IN Xw.sc --> (not ((b,a) IN hb) && not ((b,a) IN Xw.mo)) *)

let dummy15c' = true

let sc_accesses_sc_reads_restricted (xo,xw,("hb",hb)::_) =
    Pset.for_all (fun (w,r) -> (not  (is_seq_cst r) || 
      (( is_seq_cst w && (Pset.mem  (w,r)  xw.sc &&
        not (Pset.exists (fun w' ->
          is_write w' && ((loc_of w = loc_of w') && (Pset.mem 
          (w,w')  xw.sc && Pset.mem  (w',r)  xw.sc))) xo.actions )) ) ||
      ( not (is_seq_cst w) &&
        not (Pset.exists (fun w' ->
          is_write w' && ((loc_of w = loc_of w') && (Pset.mem 
          (w,w')  hb && Pset.mem  (w',r)  xw.sc))) xo.actions ) )))) xw.rf


let sc_accesses_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted", Leaf( sc_accesses_sc_reads_restricted)) ])) ])


(*********************************************** *)
(*   - 15c.1  - sc, no sc fences top level judgement *)
(*********************************************** *)

let dummy15c1 = true

let sc_accesses_memory_model =
  { consistent = sc_accesses_consistent_execution;
     relation_calculation = release_acquire_fenced_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val sc_accesses_behaviour : opsem_t -> program -> program_behaviours*)



(*********************************************** *)
(* 15d - sc_fences, no consume *)
(*********************************************** *)

let dummy15d = true

(*val sc_fenced_protocol : protocol_t*)
let sc_fenced_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed;Seq_cst]))
      | Store( _, _, mo, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release;Relaxed;Seq_cst]))
      | RMW( _, _, mo, _, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [Acq_rel;Acquire;Release;Relaxed;Seq_cst]))
      | Fence( _, _, mo)            -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed;Seq_cst]))
      | Blocked_rmw( _, _, _)       -> true )) xo.actions


let sc_fenced_sc_fences_heeded (xo,xw,("hb",hb)::_) =
    Pset.for_all (fun f -> Pset.for_all (fun f' -> Pset.for_all (fun r -> Pset.for_all (fun w -> Pset.for_all (fun w' ->
      not ( is_fence f && (is_fence f' &&
            ( (* fence restriction N3291 29.3p4 *)
              ( Pset.mem  (w,w')  xw.mo && (Pset.mem 
                (w',f)  xw.sc &&  (Pset.mem 
                (f,r)  xo.sb &&  Pset.mem 
                (w,r)  xw.rf)) ) ||
              (* fence restriction N3291 29.3p5 *)
              (( Pset.mem  (w,w')  xw.mo && (Pset.mem 
                (w',f)  xo.sb &&  (Pset.mem 
                (f,r)  xw.sc &&  Pset.mem 
                (w,r)  xw.rf)) ) ||
              (* fence restriction N3291 29.3p6 *)
              (( Pset.mem  (w,w')  xw.mo && (Pset.mem 
                (w',f)  xo.sb && (Pset.mem 
                (f,f')  xw.sc && (Pset.mem 
                (f',r)  xo.sb &&  Pset.mem 
                (w,r)  xw.rf))) ) ||
              (* SC fences impose mo N3291 29.3p7 *)
              (( Pset.mem  (w',f)  xo.sb && (Pset.mem 
                (f,f')  xw.sc && (Pset.mem 
                (f',w)  xo.sb && Pset.mem 
                (w,w')  xw.mo)) ) ||
              (* N3291 29.3p7, w collapsed first write*)
              (( Pset.mem  (w',f)  xw.sc &&  (Pset.mem 
                (f,w)  xo.sb && Pset.mem 
                (w,w')  xw.mo) ) ||
              (* N3291 29.3p7, w collapsed second write*)
              ( Pset.mem  (w',f)  xo.sb &&  (Pset.mem 
                (f,w)  xw.sc && Pset.mem 
                (w,w')  xw.mo) ))))) )) )) xo.actions) xo.actions) xo.actions) xo.actions) xo.actions


let sc_fenced_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("sc_fenced_sc_fences_heeded", Leaf( sc_fenced_sc_fences_heeded));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted", Leaf( sc_accesses_sc_reads_restricted)) ])) ])


(*********************************************** *)
(*   - 15d.1  - sc, no sc fences top level judgement *)
(*********************************************** *)

let dummy15d1 = true

let sc_fenced_memory_model =
  { consistent = sc_fenced_consistent_execution;
     relation_calculation = release_acquire_fenced_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val sc_fenced_behaviour : opsem_t -> program -> program_behaviours*)




(*********************************************** *)
(* 15e - with consume *)
(*********************************************** *)

let dummy15e = true

(*val with_consume_protocol : protocol_t*)
let with_consume_protocol (xo,_,_) =
    Pset.for_all (fun a ->
      (match a with
      | Lock( _, _, _, _)            -> true
      | Unlock( _, _, _)            -> true
      | Load( _, _, mo, _, _)         -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed;Seq_cst;Consume]))
      | Store( _, _, mo, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Release;Relaxed;Seq_cst]))
      | RMW( _, _, mo, _, _, _)        -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [Acq_rel;Acquire;Release;Relaxed;Seq_cst]))
      | Fence( _, _, mo)            -> ( Pset.mem mo  (Pset.from_list Pervasives.compare [NA;Acquire;Relaxed;Seq_cst]))
      | Blocked_rmw( _, _, _)       -> true )) xo.actions

let with_consume_cad_set actions sb dd rf = tc ( Pset.union  ( Pset.inter rf  sb)  dd )

let with_consume_dob actions rf rs cad w a =
    Pset.exists (fun w' -> Pset.exists (fun r ->
      is_consume r && (Pset.mem 
      (w,w')  rs && (Pset.mem  (w',r)  rf &&
      ( Pset.mem  (r,a)  cad || (r = a) )))) actions) actions

let with_consume_dob_set actions rf rs cad =
    let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun a x2 -> Pset.fold (fun b x2 -> if
       dependency_ordered_before actions rf rs cad a b then Pset.add (a,b) x2 else x2) actions x2) actions x2

let with_consume_ithb actions sb sw dob =
    let r = Pset.union (Pset.union   sw  dob)  (compose sw sb) in
      tc ( Pset.union r  (compose sb r))

let with_consume_consistent_ithb
      (xo,xw,_::_::("ithb",ithb)::_) =
    irrefl xo.actions ithb

let with_consume_hb actions sb ithb = Pset.union 
    sb  ithb

let with_consume_relations xo xw =
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = release_acquire_fenced_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs in
    let cad   = with_consume_cad_set xo.actions xo.sb xo.dd xw.rf in
    let dob   = with_consume_dob_set xo.actions xw.rf rs cad in
    let ithb  = with_consume_ithb xo.actions xo.sb sw dob in
    let hb    = with_consume_hb xo.actions xo.sb ithb in
    let vse   = visible_side_effect_set xo.actions hb in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs);
      ("dob", dob);
      ("cad", cad) ]



let with_consume_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("sc_fenced_sc_fences_heeded", Leaf( sc_fenced_sc_fences_heeded));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("consistent_rf",
           Node( [ ("det_read", Leaf( det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("consistent_atomic_rf", Leaf( consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted", Leaf( sc_accesses_sc_reads_restricted)) ])) ])



(*********************************************** *)
(*   - 15e.1  - with consume top level judgement *)
(*********************************************** *)

let dummy15e1 = true

let with_consume_memory_model =
  { consistent = with_consume_consistent_execution;
     relation_calculation = with_consume_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Per_location_order);
           ao_flag  = false;
           tot_flag = false }
  }


(*val with_consume_behaviour : opsem_t -> program -> program_behaviours*)






(*********************************************** *)
(* 15f - the standard model *)
(*********************************************** *)

let dummy15f = true



let standard_vsses_non_max actions lk mo hb vse =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun r x2 -> Pset.fold (fun v x2 -> Pset.fold (fun head x2 -> if
    is_at_atomic_location lk r && (Pset.mem  (head,r)  vse &&
    ( v = head ||
      ( Pset.mem  (head,v)  mo && (not ( Pset.mem (r,v)  hb) &&
        Pset.for_all (fun w -> (not 
          ( Pset.mem (head,w)  mo && Pset.mem  (w,v)  mo) ||  not ( Pset.mem (r,w)  hb))) actions)
      )
    )) then Pset.add (v,r) x2 else x2) actions x2) actions x2) actions x2



let standard_vsses actions lk mo hb vse =
  let x2 = Pset.from_list Pervasives.compare [] in Pset.fold (fun r x2 -> Pset.fold (fun v x2 -> Pset.fold (fun head x2 -> if
    is_at_atomic_location lk r && (Pset.mem 
    (head,r)  vse &&
    (not (Pset.exists (fun v' -> Pset.mem  (v',r)  vse && Pset.mem  (head,v')  mo) actions) &&
    ( v = head ||
      ( Pset.mem  (head,v)  mo && (not ( Pset.mem (r,v)  hb) &&
        Pset.for_all (fun w -> (not 
          ( Pset.mem (head,w)  mo && Pset.mem  (w,v)  mo) ||  not ( Pset.mem (r,w)  hb))) actions)
      )
    ))) then Pset.add (v,r) x2 else x2) actions x2) actions x2) actions x2


let standard_relations xo xw =
    let hrs   = hypothetical_release_sequence_set xo.actions xo.lk xw.mo in
    let rs    = release_sequence_set xo.actions xo.lk xw.mo in
    let sw    = release_acquire_fenced_synchronizes_with_set xo.actions xo.sb xo.asw xw.rf xw.lo rs hrs in
    let cad   = with_consume_cad_set xo.actions xo.sb xo.dd xw.rf in
    let dob   = with_consume_dob_set xo.actions xw.rf rs cad in
    let ithb  = with_consume_ithb xo.actions xo.sb sw dob in
    let hb    = with_consume_hb xo.actions xo.sb ithb in
    let vse   = visible_side_effect_set xo.actions hb in
    let vsses = standard_vsses xo.actions xo.lk xw.mo hb vse in
    [ ("hb", hb);
      ("vse", vse);
      ("ithb", ithb);
      ("vsses", vsses);
      ("sw", sw);
      ("rs", rs);
      ("hrs", hrs);
      ("dob", dob);
      ("cad", cad) ]


let standard_consistent_atomic_rf (xo,xw,_::_::_::("vsses",vsses)::_) =
    Pset.for_all (fun (w,r) -> (not  (is_at_atomic_location xo.lk r) || Pset.mem  
        (w,r)  vsses)) xw.rf

let standard_det_read (xo,xw,("hb",hb)::("vse",vse)::_) =
    Pset.for_all (fun r -> (not 
      (is_read r) || 
      ((Pset.exists (fun w ->  Pset.mem   (w,r)  vse) xo.actions) =
      (Pset.exists (fun w' -> Pset.mem  (w',r)  xw.rf) xo.actions)))) xo.actions


(* let standard_consistent_locks (Xo,Xw,("hb",hb)::_) = *)
(*     (forall ((a,c) IN Xw.lo).  *)
(*       is_successful_lock a && is_successful_lock c && (loc_of a = loc_of c) *)
(*       -->  *)
(*       (exists (b IN Xo.actions). (loc_of a = loc_of b) && is_unlock b && (a,b) IN Xw.lo && (b,c) IN Xw.lo)) *)


(* let standard_consistent_lo (Xo,Xw,("hb",hb)::_) = *)
(*     let mutex_actions = *)
(*       { a | forall (a IN Xo.actions) | is_lock a || is_unlock a } in *)
(*     strict_partial_order mutex_actions Xw.lo && *)
(*     total mutex_actions Xw.lo && *)
(*     forall ((a,b) IN Xw.lo). *)
(*       a IN mutex_actions && b IN mutex_actions && *)
(*       not ((b,a) IN hb) *)


let standard_consistent_execution =
  Node( [ ("well_formed_threads", Leaf( well_formed_threads));
         ("well_formed_rf", Leaf( well_formed_rf));
         ("locks_only_consistent_locks", Leaf( locks_only_consistent_locks));
         ("locks_only_consistent_lo", Leaf( locks_only_consistent_lo));
         ("consistent_mo", Leaf( consistent_mo));
         ("sc_accesses_consistent_sc", Leaf( sc_accesses_consistent_sc));
         ("sc_fenced_sc_fences_heeded", Leaf( sc_fenced_sc_fences_heeded));
         ("consistent_ithb", Leaf( consistent_ithb));
         ("consistent_rf",
           Node( [ ("standard_det_read", Leaf( standard_det_read));
                  ("consistent_non_atomic_rf", Leaf( consistent_non_atomic_rf));
                  ("standard_consistent_atomic_rf",
                     Leaf( standard_consistent_atomic_rf));
                  ("coherent_memory_use", Leaf( coherent_memory_use));
                  ("rmw_atomicity", Leaf( rmw_atomicity));
                  ("sc_accesses_sc_reads_restricted",
                     Leaf( sc_accesses_sc_reads_restricted)) ])) ])

         (* ("consistent_sc", Leaf consistent_sc); *)



(* let standard_good_mutex_use actions lk sb lo a = *)
(*     let lo_at_loc_of_a = { (x,y) | forall ((x,y) IN lo) | *)
(*                         (loc_of x = loc_of a) && (loc_of y = loc_of a) } in *)
(*         (* violated requirement: The calling thread shall own the mutex. *) *)
(*     ( is_unlock a --> *)
(*         ( exists (al IN actions). *)
(*             is_successful_lock al && (al,a) IN sb && *)
(*             adjacent_less_than lo_at_loc_of_a actions al a ) ) && *)
(*     (* violated requirement: The calling thread does not own the mutex. *) *)
(*     ( is_lock a --> *)
(*       not ( exists (al IN actions). *)
(*               is_successful_lock al && (al,a) IN sb && *)
(*               adjacent_less_than lo_at_loc_of_a actions al a ) ) *)

(* let standard_bad_mutexes (Xo,Xw,_) = *)
(*   { a | forall (a IN Xo.actions) | *)
(*     not (standard_good_mutex_use Xo.actions Xo.lk Xo.sb Xw.lo a)} *)

(* let standard_undefined_behaviour = *)
(*   [ Two ("unsequenced_races", unsequenced_races); *)
(*     Two ("data_races", data_races); *)
(*     One ("indeterminate_reads", indeterminate_reads); *)
(*     One ("standard_bad_mutexes", standard_bad_mutexes) ] *)

(*********************************************** *)
(*   - 15f.1  - single lock order top level judgement *)
(*********************************************** *)

let dummy15f1 = true

let standard_memory_model =
  { consistent = standard_consistent_execution;
     relation_calculation = standard_relations;
     undefined = locks_only_undefined_behaviour;
     relation_flags =
       {  rf_flag  = true;
           mo_flag  = true;
           sc_flag  = true;
           lo_flag  = Some( Global_order);
           ao_flag  = false;
           tot_flag = false }
  }

(*val standard_behaviour : opsem_t -> program -> program_behaviours*)




(***********************)
(* - 16 - Meta theorem *)
(***********************)

let dummy16 = true

(*
val thm1 : bool
let {hol; isabelle; coq; tex} thm1 = forall opsem p.
  locks_only_protocol  -->
  (locks_only_behaviour opsem p = release_acquire_behaviour opsem p)  
*)
